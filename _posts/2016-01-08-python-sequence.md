---
layout: post
title: "Python 序列（字符串、列表、元组）概述"
keywords: Python 序列
description: "Python序列类型概述，讲述字符串、列表、元组的通用操作符和内建函数"
category: python
tags: Python 序列
---
{% include JB/setup %}

在 Python 中有六种基本数据类型，即数字（包括整形、长整、浮点）、字符串、列表、元组、字典和布尔类型。其中，字符串、列表、元组被称之为序列。因为它们有着相同的访问模式，它们的每一个元素可以通过指定一个偏移量的方式得到。而多个元素可以通过切片操作的方式一次得到。如下图所示：
 
 ![sequence](http://ww4.sinaimg.cn/mw690/c3c88275jw1ezrv6yk72ij209d01zdfq.jpg)
 
- N == 序列的长度 == len(sequence)
 
序列是 Python 中最基本的数据结构。 序列中的每个元素都分配一个索引，及其在序列中的位置，第一个索引是0，第二个索引是1，依此类推。序列都可以进行的操作包括索引，切片，加，乘，检查成员等。
 
## 序列类型操作符
 
 序列类型的操作符主要有如下几种，按照优先级从高到底的顺序排列：
 
 <pre>
seq[ind]        获得下标为 ind 的元素 
seq[ind1:ind2] 获得下标从 ind1 到 ind2 间的元素集合 
seq * expr    序列重复 expr 次 
seq1 + seq2   连接序列 seq1 和 seq2 
obj in seq    判断 obj 元素是否包含在 seq 中 
obj not in seq 判断 obj 元素是否不包含在 seq 中 
</pre>

### 成员关系操作符 (in, not in) 

成员关系操作符用于判断一个元素是否属于一个序列。比如对字符串类型来说，就是判断一个字符是否属于这个字符串，对和元组类型来说，就代表了一个对象是否属于该对象序列。in/not in 操作符的返回值一般来讲就是 True/False，满足成员关系就返回 True，否则返回 False。该操作符的语法如下： 
 
> obj [not] in sequence 

### 连接操作符( + )

连接操作符用于把一个序列和另一个相同类型的序列做连接，语法如下:

> sequence1 + sequence2 

该表达式的结果是一个包含 sequence1 和 sequence2 的内容的**新序列**。但是这个操作不是最快或者说最有效的。对字符串来说，这个操作不如把所有的子字符串放到一个列表或可迭代对象中，然后调用一个 `join` 方法来把所有的内容连接在一起节约内存；类似地，对列表来说，我们推荐读者用列表类型的 `extend()` 方法来把两个或者多个列表对象合并.当你需要简单地把两个对象的内容合并， 或者说不能依赖于可变对象的那些没有返回值（实际上它返回一个 None）的内建方法来完成的时候时，连接操作符还是很方便的一个选择。

### 重复操作符 ( * ) 

当你需要需要一个序列的多份拷贝时，重复操作符非常有用，它的语法如下： 

> sequence * copies_int 

copies_int 必须是一个整数（不能是长整数）。像连接操作符一样，该操作符返回一个**新的**包含多份原对象拷贝的对象。

### 切片操作符 ( [], [:], [::] ) 

简单地讲， 所谓序列类型就是包含一些顺序排列的对象的一个结构。序列的访问方式类似于其他高级语言的数组，访问某一个元素时，可以通过使用方括号`[ ]`指定下标来实现，其语法如下：

> sequence[index] 

Python 序列的访问还可以通过用 `:` 来访问某一区间的元素，这就是所谓的切片，其语法如下: 
 
> sequence[starting_index:ending_index] 

通过这种方式可以得到从起始索引到结束索引之间的一"片"元素。需要注意的是，切片操作的区间是**前闭后开**的，也就是结束索引对应的元素不包含在切片所选的元素内。

序列还可以用步长索引来进行扩展的切片操作，即 `[::]`，它多出来的第三个索引值被用做步长参数。如下示例：

<pre>
>>> s = 'abcde
>>> s[::-1]   # 可以视作"翻转"操作
'hgfedcba' 
>>> s[::2]  # 隔一个取一个的操作 
'aceg' 
</pre>

## 序列类型内建函数

### 类型转换

内建函数 list(),str()和 tuple()被用做在各种序列类型之间转换。这类似于其他语言里的类型转换，但是并没有进行任何的转换。这些转换实际上是工厂函数，将对象作为参数，并将其内容(浅)拷贝到新生成的对象中。因为**一个 Python 的对象被建立，就不能更改其身份或类型**。所谓浅拷贝就是只拷贝了对对象的索引,而不是重新建立了一个对象！序列类型的转换函数如下：

<pre>
list(iter)  把可迭代对象转换为列表
str(obj)  把 obj 对象转换成字符串(对象的字符串表示法)
unicode(obj)  把对象转换成 Unicode 字符串(使用默认编码)
basestring()  抽象工厂函数,其作用仅仅是为 str 和 unicode 函数提供父类，所以不能被实例化,也不能被调用
tuple(iter)  把一个可迭代对象转换成一个元组对象
</pre>

### Operational

Python 为序列类型提供以下可操作：

- enumerate(iter)  

接受一个可迭代对象作为参数,返回一个 enumerate 对象(同时也是一个迭代器),该对象生成由 iter 每个元素的 index 值和 item 值组成的元组

- len(seq) 

返回 seq 的长度

- max(iter,key=None) or max(arg0,arg1...,key=None)  

返回 iter 或(arg0,arg1,...)中的最大值,如果指定了 key,这个 key 必须是一个可以传给 sort()方法的,用于比较的回调函数

- min(iter, key=None) or min(arg0, arg1.... key=None)  

返回 iter 里面的最小值;或者返回(arg0,arg2,...)里面的最小值;如果指定了 key,这个 key 必须是一个可以传给sort()方法的,用于比较的回调函数

- reversed(seq)   

接受一个序列作为参数,返回一个以逆序访问的迭代器

- sorted(iter, func=None, key=None, reverse=False)
   
接受一个可迭代对象作为参数,返回一个有序的列表;可选参数func,key 和 reverse 的含义跟 list.sort()内建函数的参数含义一样 

- sum(seq, init=0)

返 回 seq 和 可 选 参 数 init 的 总 和 , 其 效 果 等 同 于reduce(operator.add,seq,init)

- zip([it0, it1,... itN]) 

返回一个列表,其第一个元素是 it0,it1,...这些元素的第一个元素组成的一个元组,第二个...,类推

以上所列函数中len(),reversed()和 sum()函数只能接受序列类型对象作为参数,而剩下的则还可以接受可迭代对象做为参数,另外,max() 和 min()函数也可以接受一个参数列表。

## cmp() 函数

`cmp()` 函数用于比较两个对象x和y，如果x &lt; y ,返回负数；x == y, 返回0；x &gt; y,返回正数。但是该函数只有在python2中可用，而且在python2所有版本中都可用，而在python3中该函数已经被废弃。所以在比较对象时，可以直接用比较运算符。

当然，在 Python3 中页出现了替代 cmp 的函数，即 lt、le、eq、ne、ge、gt：

<pre>
lt(a, b) 相当于 a < b
le(a,b) 相当于 a <= b
eq(a,b) 相当于 a == b
ne(a,b) 相当于 a != b
gt(a,b) 相当于 a > b
ge(a, b)相当于 a>= b
</pre>